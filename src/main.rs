#![allow(clippy::upper_case_acronyms)]
#![feature(array_chunks, total_cmp, bool_to_option)]
extern crate core;

use image::{DynamicImage, GenericImageView, ImageResult};
use nanorand::tls::TlsWyRand;
use nanorand::Rng;
use rayon::prelude::*;

use crate::camera::Camera;
use crate::material::*;
use crate::primitive::model::{HitInfo, Model};
use crate::primitive::Triangle;
use crate::ray::Ray;
use crate::tlas::TLAS;
use crate::utility::{EPSILON, INFINITY};

#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

mod camera;
mod material;
mod onb;
mod primitive;
mod ray;
mod tlas;
mod utility;

const ASPECT_RATIO: f32 = 1.0;
const IMAGE_WIDTH: usize = 1000;
const IMAGE_HEIGHT: usize = ((IMAGE_WIDTH as f32) / ASPECT_RATIO) as usize;
const SAMPLES_PER_PIXEL: u32 = 128;
const MAX_BOUNCES: u32 = 1024;

const ENABLE_NEE: bool = true;

fn generate_halton(base_x: u32, base_y: u32, num_samples: u32) -> Vec<glam::Vec2>
{
    (0..num_samples)
        .into_par_iter()
        .map(|i: u32| {
            // x axis
            let mut x: f32 = 0.0;
            let mut denominator_x: f32 = base_x as f32;
            let mut n_x: u32 = i;
            while n_x > 0
            {
                let multiplier: u32 = n_x % base_x;
                x += (multiplier as f32) / denominator_x;
                n_x /= base_x;
                denominator_x *= base_x as f32;
            }

            // y axis
            let mut y: f32 = 0.0;
            let mut denominator_y: f32 = base_y as f32;
            let mut n_y: u32 = i;
            while n_y > 0
            {
                let multiplier: u32 = n_y % base_y;
                y += (multiplier as f32) / denominator_y;
                n_y /= base_y;
                denominator_y *= base_y as f32;
            }

            glam::Vec2::new(x, y)
        })
        .collect()
}

#[allow(dead_code)]
#[inline]
fn balance_heuristic(f: f32, g: f32) -> f32 { f / (f + g) }

#[inline]
fn power_heuristic(f: f32, g: f32) -> f32 { (f * f) / (f * f + g * g) }

fn u8_to_float(a: u8) -> f32 { ((a as f32) / 255.0).powf(2.2) }

fn f32_to_u8(a: f32) -> u8 { (a.powf(1.0 / 2.2) * 255.0) as u8 }

fn map_colour(a: &glam::Vec3A) -> [u8; 3]
{
    [
        f32_to_u8(a.x.clamp(0.0, 1.0)),
        f32_to_u8(a.y.clamp(0.0, 1.0)),
        f32_to_u8(a.z.clamp(0.0, 1.0)),
    ]
}

fn pixel_to_vec3(p: image::Rgba<u8>) -> glam::Vec3A { glam::Vec3A::new(u8_to_float(p[0]), u8_to_float(p[1]), u8_to_float(p[2])) }

fn estimate_direct(rng: &mut TlsWyRand, r: &Ray, hit_info: &HitInfo, mat: &(dyn Material), world: &TLAS, lights: &TLAS) -> glam::Vec3A
{
    let mut direct: glam::Vec3A = glam::Vec3A::ZERO;
    let incoming: glam::Vec3A = -r.direction;

    let (num_lights, light_material, light) = lights.random_primitive(rng);

    let u: f32 = 1.0 - rng.generate::<f32>().sqrt();
    let v: f32 = rng.generate::<f32>() * (1.0 - u);
    let point: glam::Vec3A = light.local_to_world(u, v);

    let o: glam::Vec3A = r.at(hit_info.t);
    let d: glam::Vec3A = point - o;

    let light_ray: Ray = Ray::new(o, d);

    if !world.any_intersect(&light_ray, 1.0 - EPSILON)
    {
        let cosine: f32 = glam::Vec3A::dot(d.normalize(), light.get_normal(u, v)).abs();
        let light_pdf: f32 = d.length_squared() / (cosine * light.area() * (num_lights as f32));

        let light_info: BsdfPdf = mat.get_brdf_pdf(incoming, light_ray.direction, hit_info);

        //Special case, ray to light might give an invalid PDF
        //All other rays are generated by the material and must have a valid PDF by construction
        if light_info.pdf > 0.0
        {
            let weight: f32 = power_heuristic(light_pdf, light_info.pdf);
            direct += light_material.get_emitted() * weight * mat.get_weakening(light_ray.direction, hit_info.normal) * light_info.bsdf / light_pdf;
        }
    }

    //Sample ray from BSDF
    let material_ray: Ray = Ray::new(o, mat.scatter_direction(rng, r.direction, hit_info.normal, hit_info.front_facing));

    if !material_ray.direction.is_nan()
    {
        if let Some((material_hi, intersected, material)) = lights.intersect(&material_ray, INFINITY)
        {
            if !world.any_intersect(&material_ray, material_hi.t * (1.0 - EPSILON))
            {
                let cosine: f32 = glam::Vec3A::dot(material_ray.direction, material_hi.normal).abs();
                let light_pdf: f32 = material_hi.t * material_hi.t / (cosine * intersected.area() * (num_lights as f32));

                let material_info: BsdfPdf = mat.get_brdf_pdf(incoming, material_ray.direction, hit_info);

                if material_info.pdf > 1e-10
                {
                    let weight: f32 = power_heuristic(material_info.pdf, light_pdf);
                    direct += material.get_emitted() * weight * mat.get_weakening(material_ray.direction, hit_info.normal) * material_info.bsdf
                        / material_info.pdf;
                }
            }
        }
    }

    direct
}

fn integrate(rng: &mut TlsWyRand, mut r: Ray, world: &TLAS, lights: &TLAS, env: &ImageResult<DynamicImage>, max_bounces: u32) -> glam::Vec3A
{
    let mut accumulated: glam::Vec3A = glam::Vec3A::ZERO;
    let mut path_weight: glam::Vec3A = glam::Vec3A::ONE;

    let mut last_delta: bool = false;

    for b in 0..=max_bounces
    {
        if let Some((hit_info, _, material)) = world.intersect(&r, INFINITY)
        {
            let wi: glam::Vec3A = -r.direction;

            if material.is_emissive() && (!ENABLE_NEE || last_delta || b == 0)
            {
                accumulated += material.get_emitted() * path_weight;
                break;
            }
            else
            {
                let is_delta: bool = material.is_delta();

                if ENABLE_NEE && !is_delta
                {
                    accumulated += path_weight * estimate_direct(rng, &r, &hit_info, material, world, lights);
                }

                r = Ray::new(
                    r.at(hit_info.t),
                    material.scatter_direction(rng, r.direction, hit_info.normal, hit_info.front_facing),
                );

                if r.direction.is_nan()
                {
                    break;
                }

                let material_info: BsdfPdf = material.get_brdf_pdf(wi, r.direction, &hit_info);

                if material_info.pdf < 1e-10
                {
                    //println!("Invalid PDF, returning early");
                    break;
                }

                path_weight *= material.get_weakening(r.direction, hit_info.normal) * material_info.bsdf / material_info.pdf;

                last_delta = is_delta;
            }
        }
        else
        {
            if env.is_ok()
            {
                let image: &DynamicImage = env.as_ref().unwrap();
                let dimensions: (u32, u32) = image.dimensions();

                let dir: glam::Vec3A = glam::Vec3A::normalize(r.direction);

                let u: f32 = dir.x.atan2(dir.z).mul_add(std::f32::consts::FRAC_1_PI * 0.5, 0.5);
                let v: f32 = dir.y.asin().mul_add(-std::f32::consts::FRAC_1_PI, 0.5);

                let x: f32 = (dimensions.0 as f32) * u;
                let y: f32 = (dimensions.1 as f32) * v;

                let x0: u32 = (x as u32) % dimensions.0;
                let y0: u32 = (y as u32) % dimensions.1;

                let x1: u32 = (x0 + 1) % dimensions.0;
                let y1: u32 = (y0 + 1) % dimensions.1;

                let x_fract: f32 = x.fract();
                let y_fract: f32 = y.fract();

                //TODO: move bi-linear interpolation into function
                let c_00: glam::Vec3A = pixel_to_vec3(image.get_pixel(x0, y0));
                let c_01: glam::Vec3A = pixel_to_vec3(image.get_pixel(x0, y1));
                let c_10: glam::Vec3A = pixel_to_vec3(image.get_pixel(x1, y0));
                let c_11: glam::Vec3A = pixel_to_vec3(image.get_pixel(x1, y1));

                let colour: glam::Vec3A = (1.0 - x_fract) * (1.0 - y_fract) * c_00
                    + (1.0 - x_fract) * y_fract * c_01
                    + x_fract * (1.0 - y_fract) * c_10
                    + x_fract * y_fract * c_11;

                accumulated += colour * path_weight;
            }
            else
            {
                accumulated += glam::Vec3A::new(0.006, 0.006, 0.006) * path_weight;
            }

            break;
        }

        if b > 3
        {
            let survive_prob: f32 = path_weight.max_element().clamp(0.0001, 0.9999);
            if rng.generate::<f32>() > survive_prob
            {
                break;
            }
            else
            {
                path_weight /= survive_prob;
            }
        }
    }

    if accumulated.is_finite()
    {
        accumulated
    }
    else
    {
        glam::Vec3A::ZERO
    }
}

fn main()
{
    println!("Loading images...");
    let env = image::io::Reader::open("images/env/HDR_110_Tunnel_Bg.jpg").unwrap().decode();

    //Materials
    println!("Creating materials...");

    let diffuse_gray = Lambertian::new(glam::Vec3A::new(0.73, 0.73, 0.73));
    let diffuse_green = Lambertian::new(glam::Vec3A::new(0.12, 0.45, 0.15));
    let diffuse_red = Lambertian::new(glam::Vec3A::new(0.65, 0.05, 0.05));
    let diffuse_blue = Lambertian::new(glam::Vec3A::new(0.05, 0.05, 0.25));
    let ggx_blue = GGXMetal::new(glam::Vec3A::new(0.1, 0.1, 0.45), 0.4);
    let ggx_blue_2 = GGXDielectric::new(glam::Vec3A::new(0.05, 0.05, 0.05), glam::Vec3A::new(0.95, 0.95, 0.95), 1.5, 0.5);
    let glass = Dielectric::new(glam::Vec3A::new(0.7, 0.7, 0.7), 1.5);

    let light = Emissive::new(glam::Vec3A::new(10.0, 10.0, 10.0));

    //Models and BVHs
    println!("Loading models, building BVHs...\n");

    let lights_model: Model = Model::new("models/cornell/cb_light.obj", &light);
    let lights: TLAS = TLAS::new(vec![lights_model]);

    let world_models: Vec<Model> = vec![
        Model::new("models/cornell/cb_light.obj", &light),
        Model::new("models/cornell/cb_main.obj", &diffuse_gray),
        Model::new("models/cornell/cb_right.obj", &diffuse_red),
        Model::new("models/cornell/cb_left.obj", &diffuse_green),
        //Model::new("models/cornell/cb_box_tall.obj", &diffuse_gray),
        //Model::new("models/cornell/cb_box_short.obj", &diffuse_gray),
        //Model::new("models/sphere_offset.obj", &glass),
        Model::new("models/zenobia.obj", &diffuse_gray),
        Model::new("models/cornell/dragon.obj", &ggx_blue),
        //Model::new("models/sphere.obj", &ggx_blue_2),
    ];

    let world: TLAS = TLAS::new(world_models);

    //Camera
    println!("\nInitialising camera...");
    let look_from: glam::Vec3A = glam::Vec3A::new(0.0, 50.0, 1000.0);
    let look_at: glam::Vec3A = glam::Vec3A::new(0.0, 50.0, 0.0);
    let up_vector: glam::Vec3A = glam::Vec3A::Y;

    let focal_distance: f32 = glam::Vec3A::length(look_at - look_from);

    let cam: Camera = Camera::new(look_from, look_at, up_vector, 40.0, ASPECT_RATIO, 0.0, focal_distance);

    //Render
    let sample_points: Vec<glam::Vec2> = generate_halton(2, 3, SAMPLES_PER_PIXEL);

    println!("Starting path-tracing...");
    let render_begin = std::time::Instant::now();

    let image_data: Vec<glam::Vec3A> = (0..(IMAGE_WIDTH * IMAGE_HEIGHT))
        .into_par_iter()
        .map(|i: usize| {
            let x: usize = i % IMAGE_WIDTH;
            let y: usize = IMAGE_HEIGHT - 1 - (i / IMAGE_WIDTH);

            sample_points
                .iter()
                .fold(glam::Vec3A::ZERO, |accumulated: glam::Vec3A, offset: &glam::Vec2| {
                    let u: f32 = (x as f32 + offset.x) / (IMAGE_WIDTH as f32);
                    let v: f32 = (y as f32 + offset.y) / (IMAGE_HEIGHT as f32);

                    let ray: Ray = cam.create_ray(u, v);
                    let mut rng = nanorand::tls_rng();
                    accumulated + integrate(&mut rng, ray, &world, &lights, &env, MAX_BOUNCES)
                })
                / (SAMPLES_PER_PIXEL as f32)
        })
        .collect();

    println!("Finished path-tracing, took {} seconds", render_begin.elapsed().as_secs());

    println!("Converting data...");
    let data: Vec<u8> = image_data.par_iter().flat_map_iter(map_colour).collect();

    println!("Saving output...");
    image::save_buffer(
        "images/output.png",
        data.as_slice(),
        IMAGE_WIDTH as u32,
        IMAGE_HEIGHT as u32,
        image::ColorType::Rgb8,
    )
    .expect("Failed writing output image");
}
